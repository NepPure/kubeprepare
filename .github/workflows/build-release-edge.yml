name: 构建和发布 KubeEdge 边缘端离线包

on:
  push:
    tags:
      - 'v*'
    paths:
      - 'edge/**'
      - '.github/workflows/build-release-edge.yml'
  workflow_dispatch:
    # 手动触发时默认使用提交短 hash 作为发布标识

permissions:
  contents: write
  packages: write

jobs:
  build-edge:
    runs-on: ubuntu-latest
    name: 构建并发布边缘端离线包 (${{ matrix.arch }})
    strategy:
      matrix:
        arch: [amd64, arm64]
        include:
          - arch: amd64
            dockerfile_platform: linux/amd64
          - arch: arm64
            dockerfile_platform: linux/arm64
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 设置QEMU支持
        uses: docker/setup-qemu-action@v3
        with:
          platforms: ${{ matrix.dockerfile_platform }}

      - name: 设置Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 设置环境变量
        id: set_env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG_VERSION="manual-edge-${GITHUB_SHA::7}"
          else
            TAG_VERSION=${GITHUB_REF#refs/tags/}
            if [ -z "$TAG_VERSION" ]; then
              echo "error: 未能解析到 tag，请使用 tag 触发或在手动触发时提供 version" >&2
              exit 1
            fi
          fi
          echo "TAG_VERSION=${TAG_VERSION}" >> $GITHUB_ENV
          echo "tag_version=${TAG_VERSION}" >> $GITHUB_OUTPUT
          echo "ARCH=${{ matrix.arch }}" >> $GITHUB_ENV
          echo "BUILD_DIR=$(pwd)/build-${{ matrix.arch }}" >> $GITHUB_ENV
          
          # 定义版本号（全局复用）
          echo "KUBEEDGE_VERSION=1.22.0" >> $GITHUB_ENV
          echo "CONTAINERD_VERSION=1.7.29" >> $GITHUB_ENV
          echo "RUNC_VERSION=1.4.0" >> $GITHUB_ENV
          echo "CNI_VERSION=1.8.0" >> $GITHUB_ENV
          echo "EDGEMESH_VERSION=v1.17.0" >> $GITHUB_ENV
          echo "MOSQUITTO_VERSION=2.0" >> $GITHUB_ENV

      - name: 构建边缘端离线包
        run: |
          set -euo pipefail  # 任何命令失败都立即终止流程
          
          echo "=== 构建边缘端离线包 (架构: ${{ matrix.arch }}) ==="
          echo "版本信息: KubeEdge ${KUBEEDGE_VERSION}, containerd ${CONTAINERD_VERSION}, runc ${RUNC_VERSION}"
          
          # 1. 下载 KubeEdge 边缘端包
          echo "[1/6] 下载 KubeEdge 边缘端包..."
          KUBEEDGE_URL="https://github.com/kubeedge/kubeedge/releases/download/v${KUBEEDGE_VERSION}/kubeedge-v${KUBEEDGE_VERSION}-linux-${{ matrix.arch }}.tar.gz"
          wget -q -O kubeedge.tar.gz "$KUBEEDGE_URL" || (echo "错误：无法下载 KubeEdge 边缘端包" && exit 1)
          tar -xzf kubeedge.tar.gz
          cp kubeedge-v${KUBEEDGE_VERSION}-linux-${{ matrix.arch }}/edge/edgecore ./edgecore
          chmod +x ./edgecore
          rm -rf kubeedge.tar.gz kubeedge-v${KUBEEDGE_VERSION}-linux-${{ matrix.arch }}
          echo "✓ KubeEdge 边缘端包下载完成"
          
          # 2. 下载 KubeEdge keadm
          echo "[2/6] 下载 KubeEdge keadm..."
          KEADM_URL="https://github.com/kubeedge/kubeedge/releases/download/v${KUBEEDGE_VERSION}/keadm-v${KUBEEDGE_VERSION}-linux-${{ matrix.arch }}.tar.gz"
          wget -q -O keadm.tar.gz "$KEADM_URL" || (echo "错误：无法下载 KubeEdge keadm" && exit 1)
          tar -xzf keadm.tar.gz
          cp keadm-v${KUBEEDGE_VERSION}-linux-${{ matrix.arch }}/keadm/keadm ./
          chmod +x ./keadm
          rm keadm.tar.gz
          echo "✓ KubeEdge keadm 下载完成"
          
          # 3. 下载 containerd 和 runc
          echo "[3/6] 下载 containerd 和 runc..."
          CONTAINERD_URL="https://github.com/containerd/containerd/releases/download/v${CONTAINERD_VERSION}/containerd-${CONTAINERD_VERSION}-linux-${{ matrix.arch }}.tar.gz"
          if ! wget -q -O containerd.tar.gz "$CONTAINERD_URL"; then
            echo "警告：无法下载 containerd v${CONTAINERD_VERSION}，尝试备用版本 v1.6.0"
            CONTAINERD_URL="https://github.com/containerd/containerd/releases/download/v1.6.0/containerd-1.6.0-linux-${{ matrix.arch }}.tar.gz"
            wget -q -O containerd.tar.gz "$CONTAINERD_URL" || (echo "错误：containerd 下载失败，离线包将无法运行容器" && exit 1)
          fi
          
          tar -xzf containerd.tar.gz || (echo "错误：containerd 解压失败" && exit 1)
          rm containerd.tar.gz
          echo "✓ containerd 下载完成"
          
          # 下载 runc
          RUNC_URL="https://github.com/opencontainers/runc/releases/download/v${RUNC_VERSION}/runc.${{ matrix.arch }}"
          wget -q -O runc "$RUNC_URL" || (echo "错误：runc 下载失败，containerd 将无法运行容器" && exit 1)
          chmod +x runc
          echo "✓ runc 下载完成"
          
          # 4. 下载 CNI 插件 (v1.22.0 要求，避免 Node NotReady)（使用环境变量中的版本号）
          echo "[4/6] 下载 CNI 插件..."
          echo "调试信息: CNI_VERSION=${CNI_VERSION}"
          CNI_URL="https://github.com/containernetworking/plugins/releases/download/v${CNI_VERSION}/cni-plugins-linux-${{ matrix.arch }}-v${CNI_VERSION}.tgz"
          echo "下载 URL: $CNI_URL"
          
          mkdir -p cni-bin
          if ! wget -q -O cni-plugins.tgz "$CNI_URL"; then
            echo "错误：CNI 插件下载失败 (URL: $CNI_URL)"
            echo "尝试显示详细错误信息..."
            wget -O cni-plugins.tgz "$CNI_URL" || true
            exit 1
          fi
          tar -xzf cni-plugins.tgz -C cni-bin || (echo "错误：CNI 插件解压失败" && exit 1)
          rm cni-plugins.tgz
          echo "✓ CNI 插件下载完成 (版本: ${CNI_VERSION})"
          ls -lh cni-bin/ | head -10
          
          # 4.5. 下载 KubeEdge、EdgeMesh 和 Mosquitto MQTT 镜像
          echo "[4.5/6] 下载 KubeEdge、EdgeMesh 和 Mosquitto MQTT 镜像..."
          mkdir -p images
          
          # KubeEdge installation-package 镜像 (keadm join 依赖)
          INSTALLATION_PKG_IMAGE="docker.io/kubeedge/installation-package:v${KUBEEDGE_VERSION}"
          
          echo "  拉取 KubeEdge installation-package 镜像: $INSTALLATION_PKG_IMAGE"
          docker pull --platform ${{ matrix.dockerfile_platform }} "$INSTALLATION_PKG_IMAGE" || (echo "错误：installation-package 镜像下载失败，keadm join 将无法离线执行" && exit 1)
          docker save "$INSTALLATION_PKG_IMAGE" -o "images/kubeedge-installation-package-v${KUBEEDGE_VERSION}.tar" || (echo "错误：镜像保存失败" && exit 1)
          echo "✓ KubeEdge installation-package 镜像已保存 (keadm join 离线必需)"
          ls -lh images/kubeedge-installation-package-v${KUBEEDGE_VERSION}.tar
          
          # KubeEdge pause 镜像 (containerd sandbox 依赖)
          PAUSE_IMAGE="docker.io/kubeedge/pause:3.6"
          
          echo "  拉取 KubeEdge pause 镜像: $PAUSE_IMAGE"
          docker pull --platform ${{ matrix.dockerfile_platform }} "$PAUSE_IMAGE" || (echo "错误：pause 镜像下载失败，containerd sandbox 将无法工作" && exit 1)
          docker save "$PAUSE_IMAGE" -o "images/kubeedge-pause-3.6.tar" || (echo "错误：镜像保存失败" && exit 1)
          echo "✓ KubeEdge pause 镜像已保存 (containerd sandbox 必需)"
          ls -lh images/kubeedge-pause-3.6.tar
          
          # EdgeMesh Agent 镜像 (边缘服务网格，使用环境变量中的版本号)
          EDGEMESH_IMAGE="docker.io/kubeedge/edgemesh-agent:${EDGEMESH_VERSION}"
          
          echo "  拉取 EdgeMesh 镜像: $EDGEMESH_IMAGE"
          docker pull --platform ${{ matrix.dockerfile_platform }} "$EDGEMESH_IMAGE" || (echo "错误：EdgeMesh 镜像下载失败，边缘节点将无法加入服务网格" && exit 1)
          docker save "$EDGEMESH_IMAGE" -o "images/docker.io-kubeedge-edgemesh-agent-${EDGEMESH_VERSION}.tar" || (echo "错误：镜像保存失败" && exit 1)
          echo "✓ EdgeMesh Agent 镜像已保存 (用于边缘服务网格)"
          ls -lh images/docker.io-kubeedge-edgemesh-agent-${EDGEMESH_VERSION}.tar
          
          # Mosquitto MQTT 镜像 (供云端 DaemonSet 调度使用，版本与 CloudCore Helm Chart 一致)
          MQTT_IMAGE="eclipse-mosquitto:1.6.15"
          
          echo "  拉取 MQTT 镜像: $MQTT_IMAGE"
          docker pull --platform ${{ matrix.dockerfile_platform }} "$MQTT_IMAGE" || (echo "错误：Mosquitto 镜像下载失败，云端 DaemonSet 将无法调度 MQTT Pod" && exit 1)
          docker save "$MQTT_IMAGE" -o "images/eclipse-mosquitto-1.6.15.tar" || (echo "错误：镜像保存失败" && exit 1)
          echo "✓ Mosquitto MQTT 镜像已保存 (版本 1.6.15，与 CloudCore Helm Chart 一致)"
          ls -lh images/eclipse-mosquitto-1.6.15.tar
          
          # 5. 创建安装元数据
          echo "[5/6] 创建安装元数据..."
          mkdir -p meta
          cat > meta/version.txt << EOFMETA
          kubeedge_version=${KUBEEDGE_VERSION}
          arch=${{ matrix.arch }}
          build_date=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          EOFMETA
          echo "✓ 安装元数据已创建"
          
          # 6. 打包离线安装包
          echo "[6/6] 创建离线安装包..."
          # install.sh 在 GITHUB_WORKSPACE/edge/install/ 目录
          INSTALL_SCRIPT="${GITHUB_WORKSPACE}/edge/install/install.sh"
          if [ ! -f "$INSTALL_SCRIPT" ]; then
            echo "错误：找不到安装脚本 $INSTALL_SCRIPT"
            ls -la "${GITHUB_WORKSPACE}/edge/install/" || echo "install 目录不存在"
            exit 1
          fi
          
          # 检查清理脚本是否存在
          CLEANUP_SCRIPT="${GITHUB_WORKSPACE}/edge/install/cleanup.sh"
          CLEANUP_OPTION=""
          if [ -f "$CLEANUP_SCRIPT" ]; then
            CLEANUP_OPTION="-C $(dirname "$CLEANUP_SCRIPT") cleanup.sh"
            echo "✓ 将包含 cleanup.sh 清理脚本"
          fi
          
          PACKAGE_NAME="kubeedge-edge-${KUBEEDGE_VERSION}-${{ matrix.arch }}.tar.gz"
          tar -czf "$PACKAGE_NAME" \
            edgecore \
            keadm \
            bin \
            runc \
            cni-bin \
            images \
            meta \
            -C "$(dirname "$INSTALL_SCRIPT")" install.sh \
            $CLEANUP_OPTION
          
          echo "✓ 包已创建: $PACKAGE_NAME"
          echo "包大小: $(du -h "$PACKAGE_NAME" | cut -f1)"

      - name: 生成校验和并准备发布文件
        run: |
          # 为边缘端包生成校验和（使用环境变量中的版本号）
          PACKAGE_NAME="kubeedge-edge-${KUBEEDGE_VERSION}-${{ matrix.arch }}.tar.gz"
          sha256sum "$PACKAGE_NAME" > "${PACKAGE_NAME}.sha256sum.txt"
          
          # 创建发布目录并收集所有文件
          mkdir -p "${GITHUB_WORKSPACE}/release-${{ matrix.arch }}"
          cp "$PACKAGE_NAME" "${GITHUB_WORKSPACE}/release-${{ matrix.arch }}/"
          cp "${PACKAGE_NAME}.sha256sum.txt" "${GITHUB_WORKSPACE}/release-${{ matrix.arch }}/"
          
          echo "=== 准备发布的文件 (${{ matrix.arch }}) ==="
          ls -lh "${GITHUB_WORKSPACE}/release-${{ matrix.arch }}/"

      - name: 上传到 GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.set_env.outputs.tag_version }}
          files: release-${{ matrix.arch }}/*
          generate_release_notes: true
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
